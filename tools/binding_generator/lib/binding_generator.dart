import 'dart:convert';
import 'dart:io';

import 'package:binding_generator/src/gdstring_additional.dart';
import 'package:binding_generator/src/type_helpers.dart';
import 'package:path/path.dart' as path;

const String templateLocation = 'lib/src/templates';

const String header = '''// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `godot_dart binding_generator`.
''';

class GenerationOptions {
  final String apiJsonLocation;
  final String outputDirectory;
  final String buildConfig;

  GenerationOptions({
    required this.apiJsonLocation,
    required this.outputDirectory,
    required this.buildConfig,
  });
}

Future<void> generate(GenerationOptions options) async {
  var file = File(options.apiJsonLocation);
  if (!file.existsSync()) {
    print("Couldn't find file: ${file.path}");
    return;
  }
  var directory = Directory(options.outputDirectory);
  if (!directory.existsSync()) {
    await directory.create(recursive: true);
  }

  var jsonString = await file.readAsString();

  var jsonApi = json.decode(jsonString) as Map<String, dynamic>;

  // TODO: Remove Output Directory
  generateBuiltinBindings(
      jsonApi, options.outputDirectory, options.buildConfig);
}

Future<void> generateBuiltinBindings(
  Map<String, dynamic> api,
  String targetDir,
  String buildConfig,
) async {
  targetDir = path.join(targetDir, 'variant');
  var directory = Directory(targetDir);
  if (!directory.existsSync()) {
    await directory.create(recursive: true);
  }

  var builtinSizes = <String, int>{};

  for (Map<String, dynamic> sizeList in api['builtin_class_sizes']) {
    if (sizeList['build_configuration'] == buildConfig) {
      for (Map<String, dynamic> size in sizeList['sizes']) {
        builtinSizes[size['name']] = size['size'];
      }
    }
  }

  for (Map<String, dynamic> builtinApi in api['builtin_classes']) {
    String className = builtinApi['name'];
    String correctedName = className;
    if (hasDartType(className)) {
      continue;
    }
    // Check for types we've implemented ourselves

    final size = builtinSizes[className]!;

    // Rename anything with name conflicts
    if (className == 'String' || className == 'Object') {
      correctedName = 'GD$className';
    }

    final destPath = path.join(targetDir, '${className.toSnakeCase()}.dart');
    final out = File(destPath).openWrite();

    out.write(header);

    // Class
    out.write('''
import 'dart:ffi';

import 'package:ffi/ffi.dart';

import '../../core/gdextension_ffi_bindings.dart';
import '../../core/gdextension.dart';

''');

    final usedClasses = getUsedTypes(builtinApi);
    for (var used in usedClasses) {
      if (used != className) {
        if (used == 'Object') {
          out.write("import '../../core/object.dart';\n");
        } else if (used == 'Variant') {
          out.write("import '../../variant/variant.dart';\n");
        } else {
          out.write("import '${used.toSnakeCase()}.dart';\n");
        }
      }
    }

    out.write('''

class $correctedName {
  static const int _size = $size;
  static final _${className}Bindings _bindings = _${className}Bindings();

  final Pointer<Uint8> _opaque = calloc<Uint8>(_size);
  Pointer<Uint8> get opaque => _opaque;

  static void initBindingsConstructorDestructor() {
''');

    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      int index = constructor['index'];
      out.write('''    _bindings.constructor_$index = gde.variantGetConstructor(
        GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_${className.toUpperSnakeCase()}, $index);
''');
    }
    if (builtinApi['has_destructor'] == true) {
      out.write('''    _bindings.destructor = gde.variantGetDestructor(
        GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_${className.toUpperSnakeCase()});
''');
    }

    out.write('  }\n');

    // Constructors
    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      int index = constructor['index'];
      final constructorName = getConstructorName(className, constructor);
      out.write('\n  $correctedName$constructorName(');
      final arguments =
          constructor['arguments'] as List<dynamic>? ?? <dynamic>[];
      if (arguments.isNotEmpty) {
        out.write('\n');
        // Parameter list
        for (Map<String, dynamic> argument in arguments) {
          final argumentDecl = getArgumentDeclaration(argument);
          out.write('    final $argumentDecl,\n');
        }
        out.write('  ) {\n');
      } else {
        out.write(') {\n');
      }

      // Allocations
      for (Map<String, dynamic> argument in arguments) {
        argumentAllocation(argument, out);
      }

      // Method call
      out.write('''
    gde.callBuiltinConstructor(_bindings.constructor_$index!, opaque.cast(), [
''');

      for (Map<String, dynamic> argument in arguments) {
        final name = argument['name'] as String;
        if (argumentNeedsAllocation(argument)) {
          out.write('      ${name.toLowerCamelCase()}Ptr.cast(),\n');
        } else {
          out.write('      ${name.toLowerCamelCase()}.opaque.cast(),\n');
        }
      }

      out.write('''
    ]); 
''');

      // Deallocations
      for (Map<String, dynamic> argument in arguments) {
        argumentFree(argument, out);
      }

      out.write('  }\n');
    }

    if (className == 'String') {
      out.write(gdStringFromString());
    } else if (className == 'StringName') {
      out.write(stringNameFromString());
    }

    out.write('}\n');

    // Binding Class
    out.write('''

class _${className}Bindings {\n''');
    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      out.write(
          '''  GDExtensionPtrConstructor? constructor_${constructor['index']};\n''');
    }
    if (builtinApi['has_destructor'] == true) {
      out.write('''  GDExtensionPtrDestructor? destructor;\n''');
    }
    out.write('}\n');

    out.close();
  }
}

void argumentAllocation(Map<String, dynamic> argument, IOSink out) {
  if (!argumentNeedsAllocation(argument)) return;

  var type = argument['type'] as String;
  var name = argument['name'] as String;
  var ffiType = getFFIType(type);
  out.write(
      '    final Pointer<$ffiType> ${name.toLowerCamelCase()}Ptr = malloc<$ffiType>(sizeOf<$ffiType>())..value = ${name.toLowerCamelCase()};\n');
}

void argumentFree(Map<String, dynamic> argument, IOSink out) {
  if (!argumentNeedsAllocation(argument)) return;

  var name = argument['name'] as String;
  out.write('    malloc.free(${name.toLowerCamelCase()}Ptr);\n');
}

String getArgumentDeclaration(Map<String, dynamic> argument) {
  final correctedType = getCorrectedType(argument['type'] as String);
  final name = argument['name'] as String;
  return '$correctedType ${name.toLowerCamelCase()}';
}

/// Generate a constructor name from arguments types. In the case
/// of a single argument constructor of the same type, the constructor
/// is called 'copy'. Otherwise it is named '.from{ArgType1}{ArgType2}'
String getConstructorName(String type, Map<String, dynamic> constructor) {
  var arguments = constructor['arguments'] as List?;
  if (arguments != null) {
    if (arguments.length == 1) {
      var argument = arguments[0] as Map<String, dynamic>;
      final argType = argument['type'] as String;
      if (argType == type) {
        return '.copy';
      } else if (argType == 'String') {
        return '.fromGDString';
      }
      return '.from${argument['type']}';
    } else {
      var name = '.from';
      for (final arg in arguments) {
        var argName = (arg['name'] as String).toLowerCamelCase();
        name += argName[0].toUpperCase() + argName.substring(1);
      }
      return name;
    }
  }

  return '';
}

List<String> getUsedTypes(Map<String, dynamic> api) {
  var usedTypes = <String>{};
  for (Map<String, dynamic> constructor in api['constructors']) {
    if (constructor.containsKey('arguments')) {
      for (Map<String, dynamic> arg in constructor['arguments']) {
        usedTypes.add(arg['type']);
      }
    }
  }
  // TODO methods
  // TODO Members

  usedTypes.removeAll(dartTypes);

  return usedTypes.toList();
}

extension StringHelpers on String {
  String toSnakeCase() {
    return replaceAllMapped(RegExp('(.)([A-Z][a-z]+)'), (match) {
      return '${match.group(1)}_${match.group(2)}';
    })
        .replaceAllMapped(RegExp('([a-z0-9])([A-Z])'), (match) {
          return '${match.group(1)}_${match.group(2)}';
        })
        .replaceAll('2_D', '2d')
        .replaceAll('3_D', '3d')
        .toLowerCase();
  }

  String toUpperSnakeCase() {
    return toSnakeCase().toUpperCase();
  }

  String toLowerCamelCase() {
    return replaceAllMapped(RegExp('(.)_([a-z])'), (match) {
      return '${match.group(1)}${match.group(2)?.toUpperCase()}';
    });
  }
}
