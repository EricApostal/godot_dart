import 'dart:convert';
import 'dart:io';

import 'package:binding_generator/src/gdstring_additional.dart';
import 'package:binding_generator/src/type_helpers.dart';
import 'package:path/path.dart' as path;

import 'src/string_extensions.dart';

const String templateLocation = 'lib/src/templates';

const String header = '''// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `godot_dart binding_generator`.
''';

class GenerationOptions {
  final String apiJsonLocation;
  final String outputDirectory;
  final String buildConfig;

  GenerationOptions({
    required this.apiJsonLocation,
    required this.outputDirectory,
    required this.buildConfig,
  });
}

Future<void> generate(GenerationOptions options) async {
  var file = File(options.apiJsonLocation);
  if (!file.existsSync()) {
    print("Couldn't find file: ${file.path}");
    return;
  }
  var directory = Directory(options.outputDirectory);
  if (!directory.existsSync()) {
    await directory.create(recursive: true);
  }

  var jsonString = await file.readAsString();

  var jsonApi = json.decode(jsonString) as Map<String, dynamic>;

  // TODO: Remove Output Directory
  generateBuiltinBindings(
      jsonApi, options.outputDirectory, options.buildConfig);
}

Future<void> generateBuiltinBindings(
  Map<String, dynamic> api,
  String targetDir,
  String buildConfig,
) async {
  targetDir = path.join(targetDir, 'variant');
  var directory = Directory(targetDir);
  if (!directory.existsSync()) {
    await directory.create(recursive: true);
  }

  var builtinSizes = <String, int>{};

  for (Map<String, dynamic> sizeList in api['builtin_class_sizes']) {
    if (sizeList['build_configuration'] == buildConfig) {
      for (Map<String, dynamic> size in sizeList['sizes']) {
        builtinSizes[size['name']] = size['size'];
      }
    }
  }

  for (Map<String, dynamic> builtinApi in api['builtin_classes']) {
    String className = builtinApi['name'];
    String correctedName = className;
    if (hasDartType(className)) {
      continue;
    }
    // Check for types we've implemented ourselves

    final size = builtinSizes[className]!;

    // Rename anything with name conflicts
    if (className == 'String' || className == 'Object') {
      correctedName = 'GD$className';
    }

    final destPath = path.join(targetDir, '${className.toSnakeCase()}.dart');
    final out = File(destPath).openWrite();

    out.write(header);

    // Class
    out.write('''
import 'dart:ffi';

import 'package:ffi/ffi.dart';

import '../../core/gdextension_ffi_bindings.dart';
import '../../core/gdextension.dart';
import 'string_name.dart';

''');

    final usedClasses = getUsedTypes(builtinApi);
    for (var used in usedClasses) {
      if (used != className) {
        if (used == 'Object') {
          out.write("import '../../core/object.dart';\n");
        } else if (used == 'Variant') {
          out.write("import '../../variant/variant.dart';\n");
        } else {
          out.write("import '${used.toSnakeCase()}.dart';\n");
        }
      }
    }

    out.write('''

class $correctedName {
  static const int _size = $size;
  static final _${className}Bindings _bindings = _${className}Bindings();

  final Pointer<Uint8> _opaque = calloc<Uint8>(_size);
  Pointer<Uint8> get opaque => _opaque;

  static void initBindings() {
''');

    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      int index = constructor['index'];
      out.write('''    _bindings.constructor_$index = gde.variantGetConstructor(
        GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_${className.toUpperSnakeCase()}, $index);
''');
    }
    if (builtinApi['has_destructor'] == true) {
      out.write('''    _bindings.destructor = gde.variantGetDestructor(
        GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_${className.toUpperSnakeCase()});
''');
    }
    out.write('    StringName name;\n');
    for (Map<String, dynamic> method in builtinApi['methods']) {
      var methodName = method['name'] as String;
      out.write('''    name = StringName.fromString('$methodName');\n''');
      out.write(
          '''    _bindings.method${methodName.toUpperCamelCase()} = gde.variantGetBuiltinMethod(
      GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_${className.toUpperSnakeCase()}, 
      name, 
      ${method['hash']},
    );
''');
    }

    out.write('  }\n');

    // Constructors
    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      int index = constructor['index'];
      final constructorName = getConstructorName(className, constructor);
      out.write('\n  $correctedName$constructorName(');
      final arguments =
          constructor['arguments'] as List<dynamic>? ?? <dynamic>[];
      if (arguments.isNotEmpty) {
        out.write('\n');
        // Parameter list
        for (Map<String, dynamic> argument in arguments) {
          final argumentDecl = getArgumentDeclaration(argument);
          out.write('    final $argumentDecl,\n');
        }
        out.write('  ) {\n');
      } else {
        out.write(') {\n');
      }

      withAllocationBlock(arguments, null, out, (ei) {
        out.write('''
    ${ei}gde.callBuiltinConstructor(_bindings.constructor_$index!, opaque.cast(), [
''');
        for (Map<String, dynamic> argument in arguments) {
          final name = escapeName(argument['name'] as String);
          if (argumentNeedsAllocation(argument)) {
            out.write('      $ei${name.toLowerCamelCase()}Ptr.cast(),\n');
          } else {
            out.write('      $ei${name.toLowerCamelCase()}.opaque.cast(),\n');
          }
        }
        out.write('''
    $ei]); 
''');
      });

      out.write('  }\n');
    }

    if (className == 'String') {
      out.write(gdStringFromString());
    } else if (className == 'StringName') {
      out.write(stringNameFromString());
    }

    // Methods
    for (Map<String, dynamic> method in builtinApi['methods']) {
      final methodName = (method['name'] as String);
      final signature = makeSignature(method, forBuiltin: true);
      out.write('''
  $signature {
''');

      List<dynamic> arguments = method['arguments'] ?? <Map<String, dynamic>>[];

      final dartReturnType = getDartReturnType(method);
      if (dartReturnType != null) {
        out.write(
            '    $dartReturnType retVal = ${getDefaultValueForType(dartReturnType)};\n');
      }
      withAllocationBlock(arguments, dartReturnType, out, (ei) {
        bool extractReturnValue = false;
        if (dartReturnType != null) {
          extractReturnValue = writeReturnAllocation(dartReturnType, out);
        }
        final retParam = dartReturnType != null ? 'retPtr.cast()' : 'nullptr';
        final thisParam =
            method['is_static'] == true ? 'nullptr' : 'opaque.cast()';
        out.write('''
    ${ei}gde.callBuiltinMethodPtr(_bindings.method${methodName.toUpperCamelCase()}, $thisParam, $retParam, [
''');
        for (Map<String, dynamic> argument in arguments) {
          final name = escapeName(argument['name'] as String);
          if (argumentNeedsAllocation(argument)) {
            out.write('      $ei${name.toLowerCamelCase()}Ptr.cast(),\n');
          } else {
            out.write('      $ei${name.toLowerCamelCase()}.opaque.cast(),\n');
          }
        }

        out.write('''
    $ei]);
''');
        if (dartReturnType != null && extractReturnValue) {
          out.write('      retVal = retPtr.value;\n');
        }
      });

      if (dartReturnType != null) {
        out.write('    return retVal;\n');
      }

      out.write('  }\n\n');
    }

    out.write('}\n');

    // Binding Class
    out.write('''

class _${className}Bindings {\n''');
    for (Map<String, dynamic> constructor in builtinApi['constructors']) {
      out.write(
          '''  GDExtensionPtrConstructor? constructor_${constructor['index']};\n''');
    }
    if (builtinApi['has_destructor'] == true) {
      out.write('''  GDExtensionPtrDestructor? destructor;\n''');
    }
    for (Map<String, dynamic> method in builtinApi['methods']) {
      var methodName = method['name'] as String;
      methodName = methodName.toUpperCamelCase();
      out.write('''  GDExtensionPtrBuiltInMethod? method$methodName;\n''');
    }
    out.write('}\n');

    out.close();
  }
}

void argumentAllocation(Map<String, dynamic> argument, IOSink out) {
  if (!argumentNeedsAllocation(argument)) return;

  var type = argument['type'] as String;
  var name = escapeName(argument['name'] as String);
  var ffiType = getFFIType(type);
  out.write(
      '      final ${name.toLowerCamelCase()}Ptr = arena.allocate<$ffiType>(sizeOf<$ffiType>())..value = ${name.toLowerCamelCase()};\n');
}

bool writeReturnAllocation(String returnType, IOSink out) {
  final nativeType = getFFIType(returnType);
  String indent = '      ';
  out.write(indent);
  if (nativeType == null) {
    out.write('final retPtr = retVal.opaque.cast();\n');
    return false;
  } else {
    out.write(
        'final retPtr = arena.allocate<$nativeType>(sizeOf<$nativeType>());\n');
    return true;
  }
}

void withAllocationBlock(
  List<dynamic> arguments,
  String? dartReturnType,
  IOSink out,
  void Function(String indent) writeBlock,
) {
  var indent = '';
  var needsArena = dartReturnType != null ||
      arguments.any((dynamic arg) => argumentNeedsAllocation(arg));
  if (needsArena) {
    indent = '  ';
    out.write('''
    using((arena) {
''');
    for (Map<String, dynamic> arg in arguments) {
      argumentAllocation(arg, out);
    }
  }
  writeBlock(indent);
  if (needsArena) {
    out.write('    });\n');
  }
}

void argumentFree(Map<String, dynamic> argument, IOSink out) {
  if (!argumentNeedsAllocation(argument)) return;

  var name = escapeName(argument['name'] as String);
  out.write('    malloc.free(${name.toLowerCamelCase()}Ptr);\n');
}

String getArgumentDeclaration(Map<String, dynamic> argument) {
  final correctedType = getCorrectedType(argument['type'] as String);
  final name = escapeName(argument['name'] as String);
  return '$correctedType ${name.toLowerCamelCase()}';
}

/// Generate a constructor name from arguments types. In the case
/// of a single argument constructor of the same type, the constructor
/// is called 'copy'. Otherwise it is named '.from{ArgType1}{ArgType2}'
String getConstructorName(String type, Map<String, dynamic> constructor) {
  var arguments = constructor['arguments'] as List?;
  if (arguments != null) {
    if (arguments.length == 1) {
      var argument = arguments[0] as Map<String, dynamic>;
      final argType = argument['type'] as String;
      if (argType == type) {
        return '.copy';
      } else if (argType == 'String') {
        return '.fromGDString';
      }
      return '.from${argument['type']}';
    } else {
      var name = '.from';
      for (final arg in arguments) {
        var argName = escapeName((arg['name'] as String)).toLowerCamelCase();
        name += argName[0].toUpperCase() + argName.substring(1);
      }
      return name;
    }
  }

  return '';
}

String makeSignature(
  Map<String, dynamic> functionData, {
  bool forBuiltin = true,
}) {
  var modifiers = '';
  var returnType = getDartReturnType(functionData) ?? 'void';
  String? returnMeta;

  if (functionData['is_static'] == true) {
    modifiers = 'static ';
  }

  var methodName = (functionData['name'] as String).toLowerCamelCase();

  var signature = '$modifiers$returnType $methodName(';

  final List<dynamic>? parameters = functionData['arguments'];
  if (parameters != null) {
    List<String> paramSignature = [];

    for (int i = 0; i < parameters.length; ++i) {
      Map<String, dynamic> parameter = parameters[i];
      final type = getCorrectedType(parameter['type'], meta: parameter['meta']);

      // TODO: Default values
      var paramName =
          escapeName((parameter['name'] as String)).toLowerCamelCase();
      paramSignature.add('$type $paramName');
    }
    signature += paramSignature.join(', ');
  }

  signature += ')';

  return signature;
}

List<String> getUsedTypes(Map<String, dynamic> api) {
  var usedTypes = <String>{};
  for (Map<String, dynamic> constructor in api['constructors']) {
    if (constructor.containsKey('arguments')) {
      for (Map<String, dynamic> arg in constructor['arguments']) {
        usedTypes.add(arg['type']);
      }
    }
  }

  for (Map<String, dynamic> method in api['methods']) {
    if (method.containsKey('arguments')) {
      for (Map<String, dynamic> arg in method['arguments']) {
        usedTypes.add(arg['type']);
      }
    }
    if (method.containsKey('return_type')) {
      usedTypes.add(method['return_type']);
    } else if (method.containsKey('return_value')) {
      usedTypes.add(getTypeFromArgument(method['return_value']));
    }
  }

  if (api.containsKey('members')) {
    for (Map<String, dynamic> member in api['members']) {
      usedTypes.add(member['type']);
    }
  }

  usedTypes.removeAll(dartTypes);
  // Already included
  usedTypes.remove('StringName');

  return usedTypes.toList();
}

String getTypeFromArgument(Map<String, dynamic> argument) {
  String type = argument['type'];
  String? meta = argument['meta'];

  type = type.replaceFirst('const ', '');
  if (type.endsWith('*')) {
    type = type.substring(0, type.length - 1);
  }

  // Handle typed arrays?
  type = getCorrectedType(type, meta: meta);

  return type;
}

String? getDartReturnType(Map<String, dynamic> method) {
  String? returnType;
  String? returnMeta;

  if (method.containsKey('return_type')) {
    returnType = getCorrectedType(method['return_type']);
  } else if (method.containsKey('return_value')) {
    final returnValue = method['return_value'] as Map<String, dynamic>;
    returnType = returnValue['type'];
    if (returnValue.containsKey('meta')) {
      returnMeta = method['return_value']['meta'];
    }

    returnType = getCorrectedType(returnType!, meta: returnMeta);
  }

  return returnType;
}
